var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Numa.jl",
    "title": "Numa.jl",
    "category": "page",
    "text": ""
},

{
    "location": "#Numa.gradshfsps-Union{Tuple{D}, Tuple{LagrangianRefFE{D},Array{SArray{Tuple{D},Float64,1,D},N} where N}} where D",
    "page": "Numa.jl",
    "title": "Numa.gradshfsps",
    "category": "method",
    "text": "Compute shape functions gradients (to be re-implemented)\n\n\n\n\n\n"
},

{
    "location": "#Numa.shfsps-Union{Tuple{D}, Tuple{LagrangianRefFE{D},Any}} where D",
    "page": "Numa.jl",
    "title": "Numa.shfsps",
    "category": "method",
    "text": "Compute shape functions in a set of points\n\n\n\n\n\n"
},

{
    "location": "#Numa.FESpace",
    "page": "Numa.jl",
    "title": "Numa.FESpace",
    "category": "type",
    "text": "FE Space structure, where only one RefFE is possible in the whole mesh (to be improved in the future)\n\n\n\n\n\n"
},

{
    "location": "#Numa.LagrangianRefFE",
    "page": "Numa.jl",
    "title": "Numa.LagrangianRefFE",
    "category": "type",
    "text": "Reference Finite Element a la Ciarlet, i.e., it relies on a local function (polynomial) space, an array of nodes (DOFs), and a polytope (cell topology). The rank of the approximating field can be arbitrary. The current implementation relies on the prebasis (e.g., monomial basis of polynomials) and a change-of-basis (using the node array) to generate the canonical basis, i.e., the shape functions.\n\n\n\n\n\n"
},

{
    "location": "#Numa.MPoint",
    "page": "Numa.jl",
    "title": "Numa.MPoint",
    "category": "type",
    "text": "The mutable version of Point{D}\n\n\n\n\n\n"
},

{
    "location": "#Numa.MTensorValue",
    "page": "Numa.jl",
    "title": "Numa.MTensorValue",
    "category": "type",
    "text": "Mutable version of TensorValue{D,DD}\n\n\n\n\n\n"
},

{
    "location": "#Numa.MVectorValue",
    "page": "Numa.jl",
    "title": "Numa.MVectorValue",
    "category": "type",
    "text": "Mutable version of VectorValue{D}\n\n\n\n\n\n"
},

{
    "location": "#Numa.Point",
    "page": "Numa.jl",
    "title": "Numa.Point",
    "category": "type",
    "text": "Type representing a point of D dimensions\n\n\n\n\n\n"
},

{
    "location": "#Numa.ScalarValue",
    "page": "Numa.jl",
    "title": "Numa.ScalarValue",
    "category": "type",
    "text": "Type representing a scalar value\n\n\n\n\n\n"
},

{
    "location": "#Numa.TensorValue",
    "page": "Numa.jl",
    "title": "Numa.TensorValue",
    "category": "type",
    "text": "Type representing a tensor value of dimension D\n\n\n\n\n\n"
},

{
    "location": "#Numa.VectorValue",
    "page": "Numa.jl",
    "title": "Numa.VectorValue",
    "category": "type",
    "text": "Type representing a vector value of dimension D\n\n\n\n\n\n"
},

{
    "location": "#Numa.RefFE",
    "page": "Numa.jl",
    "title": "Numa.RefFE",
    "category": "type",
    "text": "Abstract Reference Finite Element\n\n\n\n\n\n"
},

{
    "location": "#Numa.jl-1",
    "page": "Numa.jl",
    "title": "Numa.jl",
    "category": "section",
    "text": "Documentation for the Numa libraryModules = [Numa,]\nOrder   = [:function, :type]"
},

]}
